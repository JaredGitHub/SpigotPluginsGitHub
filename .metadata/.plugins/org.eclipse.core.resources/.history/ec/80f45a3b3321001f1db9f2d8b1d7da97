package me.Jared.Listeners;

import java.util.HashMap;

import org.bukkit.Bukkit;
import org.bukkit.Effect;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.block.Block;
import org.bukkit.entity.Damageable;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Projectile;
import org.bukkit.event.Event;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.entity.EntityDamageEvent.DamageCause;
import org.bukkit.event.entity.EntityDeathEvent;
import org.bukkit.event.entity.ProjectileHitEvent;
import org.bukkit.util.BlockIterator;

import me.Jared.GunsPlugin;
import me.Jared.Events.GunsBulletCollideEvent;
import me.Jared.Events.GunsDamageEntityEvent;
import me.Jared.Events.GunsKillEntityEvent;
import me.Jared.Guns.Bullet;
import me.Jared.Guns.Gun;
import me.Jared.Guns.GunPlayer;

public class EntityListener implements Listener {
    public static HashMap<Entity, HashMap<Entity, Long>> s = new HashMap<>();
    public static HashMap<Entity, HashMap<EntityDamageEvent.DamageCause, Long>> ss = new HashMap<>();
    public static HashMap<Integer, Long> lastBlood = new HashMap<>();

    @EventHandler
    public void onProjectileHit(ProjectileHitEvent event) {
        Projectile check = event.getEntity();
        Bullet bullet = GunsPlugin.getPlugin.getBullet(check.getEntityId());
        if (bullet != null) {
            bullet.onHit();
            bullet.setNextTickDestroy();
            BlockIterator iterator = new BlockIterator(event.getEntity().getWorld(), event.getEntity().getLocation().toVector(), event.getEntity().getVelocity().normalize(), 0.0, 4);
            Block hitBlock = null;
            while (iterator.hasNext()) {
                hitBlock = iterator.next();
                if (hitBlock.getType() != Material.AIR) {
                    break;
                }
            }
            if (hitBlock != null) {
                hitBlock.getWorld().playEffect(hitBlock.getLocation(), Effect.STEP_SOUND, hitBlock.getType());
                GunsBulletCollideEvent evv = new GunsBulletCollideEvent(bullet.getShooter(), bullet.getGun(), hitBlock);
                Bukkit.getPluginManager().callEvent(evv);
            }
            bullet.setNextTickDestroy();
            if (hitBlock != null) {
                switch (hitBlock.getType()) {
                    case GLASS:
                    case GLASS_PANE:
                        breakGlass(hitBlock);
                        break;
                    default:
                        break;
                }
            }
        }
    }

    private void breakGlass(Block hitBlock) {
        if (hitBlock.getWorld().getName().equals("warz")) {
            hitBlock.setType(Material.AIR);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    public void onEntityDeath(EntityDeathEvent event) {
        LivingEntity livingEntity = event.getEntity();
        EntityDamageEvent lastDamageEvent = livingEntity.getLastDamageCause();
        if (lastDamageEvent instanceof EntityDamageByEntityEvent) {
            Entity damager = ((EntityDamageByEntityEvent) lastDamageEvent).getDamager();
            if (damager instanceof Projectile) {
                Bullet bullet = GunsPlugin.getPlugin.getBullet(damager);
                if (bullet != null) {
                    GunPlayer shooter = bullet.getShooter();
                    Gun usedGun = bullet.getGun();
                    GunsKillEntityEvent killEvent = new GunsKillEntityEvent(shooter, usedGun, livingEntity);
                    Bukkit.getPluginManager().callEvent(killEvent);
                }
            }
        }
    }

    public boolean damage(Entity damager, Entity damaged) {
        if (!s.containsKey(damager)) {
            HashMap<Entity, Long> hashMap = new HashMap<>();
            hashMap.put(damaged, System.currentTimeMillis());
            s.put(damager, hashMap);
            return true;
        }
        HashMap<Entity, Long> lastOfEntity = s.get(damager);
        if (lastOfEntity.containsKey(damaged) && System.currentTimeMillis() <= lastOfEntity.get(damaged) + 600L) {
            return false;
        }
        lastOfEntity.put(damaged, System.currentTimeMillis());
        s.put(damager, lastOfEntity);
        return true;
    }

    public boolean damage(EntityDamageEvent.DamageCause cause, Entity damaged) {
        if (cause != EntityDamageEvent.DamageCause.PROJECTILE) {
            if (cause == EntityDamageEvent.DamageCause.FIRE_TICK) {
                cause = EntityDamageEvent.DamageCause.LAVA;
            }
            if (!ss.containsKey(damaged)) {
                HashMap<EntityDamageEvent.DamageCause, Long> hashMap = new HashMap<>();
                hashMap.put(cause, System.currentTimeMillis());
                ss.put(damaged, hashMap);
                return true;
            }
            HashMap<EntityDamageEvent.DamageCause, Long> lastOfEntity = ss.get(damaged);
            if (lastOfEntity.containsKey(cause) && System.currentTimeMillis() <= lastOfEntity.get(cause) + 600L) {
                return false;
            }
            lastOfEntity.put(cause, System.currentTimeMillis());
            ss.put(damaged, lastOfEntity);
            return true;
        }
        return true;
    }

    @EventHandler
    public void getDamage(EntityDamageEvent e) {
        if (e.getEntity() instanceof LivingEntity) {
            LivingEntity hurt = (LivingEntity) e.getEntity();
            DamageCause cause = e.getCause();
            if (cause == DamageCause.ENTITY_EXPLOSION || cause == DamageCause.PROJECTILE) {
                hurt.setMaximumNoDamageTicks(0);
                e.setCancelled(false);
                return;
            }
            if (!this.damage(cause, hurt)) {
                e.setCancelled(true);
            }
            hurt.setMaximumNoDamageTicks(0);
        }
    }

    @EventHandler
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (event.isCancelled()) {
            return;
        }
        Entity damager = event.getDamager();
        if (event.getEntity() instanceof Damageable) {
            Bullet bullet;
            Damageable hurt = (Damageable) event.getEntity();
            if (!(damager instanceof Projectile) && !this.damage(damager, hurt)) {
                event.setCancelled(true);
                return;
            }
            if (damager instanceof Projectile && (bullet = GunsPlugin.getPlugin.getBullet(((Projectile) damager).getEntityId())) != null) {
                if (bullet.getShooter().getPlayer().getEntityId() == hurt.getEntityId()) {
                    event.setCancelled(true);
                }
                boolean headshot = this.isNear(bullet.getProjectile().getLocation(), ((LivingEntity) hurt).getEyeLocation(), 0.26);
                GunsDamageEntityEvent pvpgundmg = new GunsDamageEntityEvent(event, bullet.getShooter(), bullet.getGun(), event.getEntity(), headshot);
                GunsPlugin.getPlugin.getServer().getPluginManager().callEvent(pvpgundmg);
                if (!pvpgundmg.isCancelled() && !event.isCancelled()) {
                    double damage = pvpgundmg.getDamage();
                    double mult = 1.0;
                    if (pvpgundmg.isHeadshot()) {
                        mult = 2.0;
                        hurt.getWorld().playSound(hurt.getLocation(), Sound.ENTITY_ZOMBIE_BREAK_WOODEN_DOOR, 1, 1);
                    }
                    event.setDamage(damage * mult);
                    bullet.getGun().doKnockback(hurt, bullet.getVelocity());
                    int armorPenetration = bullet.getGun().getArmorPenetration();
                    if (armorPenetration > 0) {
                        double newHealth = hurt.getHealth() - armorPenetration;
                        hurt.setHealth(Math.max(0.0, Math.min(newHealth, 20.0)));
                    }
                    this.doBlood(hurt, bullet);
                }
            }
        }
    }

    public void doBlood(Entity entity, Bullet bullet) {
        if (lastBlood.containsKey(entity.getEntityId()) && System.currentTimeMillis() - lastBlood.get(entity.getEntityId()) < 100L) {
            return;
        }
        entity.getWorld().playEffect(entity.getLocation(), Effect.STEP_SOUND, Material.REDSTONE_BLOCK);
        bullet.getGun().doKnockback(entity, bullet.getVelocity());
        lastBlood.put(entity.getEntityId(), System.currentTimeMillis());
    }

    private boolean isNear(Location location, Location eyeLocation, double d) {
        return Math.abs(location.getY() - eyeLocation.getY()) <= d;
    }
}
